
struct Header {
	u32 classId; // generated by the DagorAssetExplorer : always 0x77f8232f for rendInst
	
	u32 lodHdrSz; // packedFields?
	
	u32 texCnt; // 0xFFFFFFFF if we use desc files
	u32 matCnt; // 0xFFFFFFFF if we use desc files
	u32 vdataNum;
	u32 mvdHdrSz; // & 0x3FFFFFFF
	
	if (texCnt != 0xFFFFFFFF && matCnt != 0xFFFFFFFF) {
		// retrive matt and tex data
	}
};

struct CompressedData {
	u24 cSz;
	u8 cMethod;
	padding[cSz];
};

struct Vector3f {
	float x;
	float y; // z and y are inverted in dagor
	float z;
};
struct Vector4f {
	float x;
	float y;
	float z;
	float w;
};

struct BBox3f {
	Vector3f mins;
	Vector3f maxs;
};

struct OcclusionData {
	u32 unknown;
	
	padding[4];
	
	float unknown1;
	
	padding[4];
};

struct DynSceneResNameMapResource {
	u32 resNameMapSz;
	
	u32 nameMapIndicesOfs;
	u32 nameCnt;
	
	padding[8];
	
	u32 skinNodesOfs;
	u32 skinNodesCnt;
	
	padding[8];
	
	char nameMap[nameMapIndicesOfs - 0x20];
	u64 nameMapIndices[nameCnt];
};

struct RigidObject {
	u64 shaderMeshPtr;
	Vector3f sph_c;
	float sph_r;
	u32 nodeId;
	u32 _resv;
	
};

struct ShaderMeshElem {
	u64 ShaderElementPtr;
	u64 ShaderMaterialPtr;
	u64 VertexDataPtr;
	
	u32 vdOrderIndex;
	u32 startV;
	u32 numV;
	u32 startI;
	u32 numFace;
	u32 baseVertex;
};


#include <std/io.pat>
struct ShaderMesh {
	u32 elemOfs; // actually these are u64 dptr
	u32 elemCnt;
	
	padding[8]; // u64 dcnt
	
	u16 stageEndElemIdx[8];
	s32 __deprecatedMaxMatPass;
	u32 _resv;
	
	
	if (elemCnt > 0 && elemCnt < 100) { // safeguard for debug purposes
		if (__deprecatedMaxMatPass < 0) {
		   ShaderMeshElem elem[elemCnt];
	   } else {
		   ShaderMeshElem elem[elemCnt + stageEndElemIdx[2]];
	   }
	} else if (elemCnt > 100) {
	   std::print("error @ {}", addressof(elemOfs));
	}
};


struct ShaderMeshResource {
	ShaderMesh mesh;
	u32 resSz;
	u32 _resv;
};

struct Lod {
	u32 HdrSz;
	
	u32 rigidCnt;
	padding[8];
	
	u32 skinPtr;
	u32 skinCnt;
	padding[8];
	
	RigidObject rigids[rigidCnt];
	
	if (skinPtr > 0) {
	  padding[HdrSz + 8];
	}
	
	ShaderMesh mesh[rigidCnt];
	
};

struct ModelData {
	u32 dataSz;
	u32 lodCnt;
	
	padding[8];
	
	BBox3f bbox;
	
	if (dataSz > 0x28) {
    	float bpC254[4];
    	float bpC255[4];
	}
	
	OcclusionData occ[lodCnt];
	
	DynSceneResNameMapResource names;
	
	u16 skinNodes[names.skinNodesCnt];
	
	padding[4 - (((sizeof(skinNodes) + addressof(skinNodes)) - addressof(names)) - names.resNameMapSz) % 4];
	
};

struct ShaderSkinnedMeshResource {
	u32 cnt;
    
	if (cnt > 0) {
        u32 sz;
    	
    	u64 ptr;
    	
    	u32 texCnt;
    	u32 matCnt;
    	
    	
    	u32 unknown;
    	
    	u24 cDataSz;
    	u8 cDatMeth;
    	
    	CompressedData cdata;
    	
    	u32 t;
    }
};


Header Hdr @ 0;
CompressedData mvd @ sizeof(Hdr);
ModelData modelData @ addressof(mvd) + sizeof(mvd);
Lod lods[modelData.lodCnt] @ addressof(modelData) + sizeof(modelData);
ShaderSkinnedMeshResource ssm @ addressof(lods) + sizeof(lods);